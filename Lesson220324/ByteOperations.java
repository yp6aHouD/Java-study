package Lesson220324;
import static java.lang.System.out;

public class ByteOperations 
{
    public static void main(String[] args)
    {
        int a = 15, b = 12;

        /* 
         * ~
         * побитовое отрицание
         * меняет 0 на 1 и наоборот
         * если а = 0000 1111, то после отрицания
         * ~а = 1111 0000 = -16
         */
        out.println("~a значение = " + ~a);

        /*
         * <<
         * побитовый сдвиг влево на 2 позиции
         * если а = 0000 1111, то после сдвига
         * а2 = 2^2 * 15 = 60 = 0011 1100
         */
        out.println("a << 2 значение = " + (a << 2)); // каждый сдвиг влево = умножение на 2

        /*
         * >>
         * побитовый сдвиг вправо на 2 позиции
         * если а = 0000 1111, то после сдвига
         * а2 = 15 / 2^2 = 3.75, но правая часть отсекается
         * => 3 = 0000 0011
         */
        out.println("a << 2 значение = " + (a >> 2)); // каждый сдвиг вправо = деление на 2

        /* 
         * &
         * побитовое "и" 
         * оставляет за единицу только те биты, которые равны у обоих чисел
         * если а = 0000 1111, b = 0000 1100, то
         * а & b = 0000 1100 = 12
         */
        out.print("a & b значение = ");
        out.println(a & b);
        
        /* 
        * |
        * побитовое "или"
        * оставляет за единицу только те биты, которые равны 1 хотя бы у одного числа
        * если а = 0000 1111, b = 0000 1100, то
        * а | b = 0000 1111 = 15
        */
        out.print("a | b значение = ");
        out.println(a | b);
        
        
        /* 
         * побитовое исключающее "или" XOR
         * оставляет за единицу только те биты, которые различаются
         * удаляет одинаковые единицы и нули
         * если а = 0000 1111, b = 0000 1100, то
         * а ^ b = 0000 0011 = 3
         */
        out.print("a ^ b значение = ");
        out.println(a ^ b);
        out.println("----------");

        out.println((-5) & (-4));
        out.println((-5) ^ (-4));
        out.println((-5) >> 2);

        /* 
         * 1000 0101 это код числа -5
         * 1111 1011 это комплементарный 补码 числа -5 (первую цифру не трогаем)
         * 1111 1011 << 2 = 1110 1100
         * вычитаем 1 = 1110 1011
         * переворачиваем = 1001 0100
         * получаем -20
         */
        out.println((-5) << 2);

        int x = 123456789;
        out.print("Binary code of " + x + " = ");
        ByteOperations. toBinary(x);
        out.println();
        
        out.print("Binary code of " + a + " = ");
        ByteOperations.toBinary(a);
        out.println();
        
        out.println("-----------------");
        
        ByteOperations.toBinary(x);
        out.println();

        int y = x & (~0xFF); // х И 0000 0000 (~0xFF = 0000 0000), первые цифры = 1, т. к. ~0xFF
        ByteOperations.toBinary(y);
        out.println();

        
        int z = x ^ (x & 0xFF); // X & 0xFF = это копия последних 8 цифр числа х
        ByteOperations.toBinary(z);            // x ^ (копия последних цифр) = первые цифры неизменны
        out.println();          // последние 8 цифр удаляются XOR
        
    }

    static void toBinary(int num)
    {
        if (num == 0) return;
        else toBinary(num / 2);
        out.print(num % 2);
    }
}
